aircraft wise:

# Define the SPARQL query for aircraft-wise data
query_aircraft = """
PREFIX : <http://api.stardog.com/>
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>

SELECT ?aircraft_model_name (ROUND(SUM(?revenue_gap_value) * 1000) / 1000 AS ?total_revenue_gap)
WHERE {
  {
    SELECT DISTINCT ?aircraft_model_name ?revenue_gap ?revenue_gap_value
    WHERE {
      # Ensure we're dealing with aircraft models
      ?artifact_identifier_aircraft_model rdf:type :Designative_Information_Content_Entity .
      ?artifact_identifier_aircraft_model :designates ?aircraft_model .
      ?aircraft_model rdf:type :Artifact_Model .
      ?artifact_identifier_aircraft_model :generically_depends_on ?ibe_aircraft_model .
      ?ibe_aircraft_model :has_text_value ?aircraft_model_name .
      FILTER(STRSTARTS(STR(?aircraft_model), STR(:aircraft_model_)))

      # Aircraft model prescribes part aggregates
      ?aircraft_model :prescribes ?part_aggregate .

      # Part aggregate bears revenue gaps
      ?part_aggregate :bearer_of ?revenue_gap .

      # Retrieve the measurement of the revenue gap
      ?measurement :is_measurement_of ?revenue_gap .
      ?measurement :generically_depends_on ?ibe_rev_gap_value .

      # Get the revenue gap value
      ?ibe_rev_gap_value :has_decimal_value ?revenue_gap_value_literal .
      BIND(xsd:decimal(?revenue_gap_value_literal) AS ?revenue_gap_value)
    }
  }
}
GROUP BY ?aircraft_model_name
"""

# Execute the query
with stardog.Connection(database_name, **conn_details) as conn:
    results_aircraft = conn.select(query_aircraft)

Cell 4: Parse Results into DataFrame

python

# Parse the results
data_aircraft = results_aircraft
variables = data_aircraft['head']['vars']
bindings = data_aircraft['results']['bindings']
rows = []

for binding in bindings:
    row = {}
    for var in variables:
        if var in binding:
            value = binding[var]['value']
            # Convert numerical values
            if binding[var]['type'] == 'literal' and 'datatype' in binding[var]:
                datatype = binding[var]['datatype']
                if datatype in (
                    'http://www.w3.org/2001/XMLSchema#decimal',
                    'http://www.w3.org/2001/XMLSchema#float',
                    'http://www.w3.org/2001/XMLSchema#double',
                    'http://www.w3.org/2001/XMLSchema#integer',
                    'http://www.w3.org/2001/XMLSchema#int',
                ):
                    value = float(value)
            row[var] = value
        else:
            row[var] = None
    rows.append(row)

# Create DataFrame
df_aircraft = pd.DataFrame(rows)
df_aircraft['total_revenue_gap'] = pd.to_numeric(df_aircraft['total_revenue_gap'])

Cell 5: Plot Aircraft-wise Data

python

# Sort data
df_aircraft = df_aircraft.sort_values('total_revenue_gap', ascending=False)

# Set figure size
plt.figure(figsize=(12, len(df_aircraft) * 0.5))

# Create horizontal bar chart
bars = plt.barh(df_aircraft['aircraft_model_name'], df_aircraft['total_revenue_gap'], color='skyblue')

# Format x-axis with currency
plt.gca().xaxis.set_major_formatter(formatter)

# Add labels and title
plt.xlabel('Total Revenue Gap', fontsize=14)
plt.ylabel('Aircraft Model Name', fontsize=14)
plt.title('Total Revenue Gap per Aircraft Model', fontsize=16)

# Adjust y-ticks
plt.yticks(fontsize=10)

# Invert y-axis
plt.gca().invert_yaxis()

# Adjust layout
plt.tight_layout()

# Show plot
plt.show()

==============================================================================================

4. Plot Part Number-wise Data

Similarly, let's plot data based on part numbers.
Cell 6: Define and Execute Part Number-wise Query

python

# Define the SPARQL query for part number-wise data
query_part_number = """
PREFIX : <http://api.stardog.com/>
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>

SELECT ?part_number (ROUND(SUM(?revenue_gap_value) * 1000) / 1000 AS ?total_revenue_gap)
WHERE {
  {
    SELECT DISTINCT ?part_number ?revenue_gap ?revenue_gap_value
    WHERE {
      # Ensure we're dealing with part models
      ?artifact_identifier_part_model rdf:type :Designative_Information_Content_Entity .
      ?artifact_identifier_part_model :designates ?part_model .
      ?part_model rdf:type :Artifact_Model .
      ?artifact_identifier_part_model :generically_depends_on ?ibe_part_model .
      ?ibe_part_model :has_text_value ?part_number .
      FILTER(STRSTARTS(STR(?part_model), STR(:part_model_)))

      # Part model prescribes part aggregates
      ?part_model :prescribes ?part_aggregate .

      # Part aggregate bears revenue gaps
      ?part_aggregate :bearer_of ?revenue_gap .

      # Retrieve the measurement of the revenue gap
      ?measurement :is_measurement_of ?revenue_gap .
      ?measurement :generically_depends_on ?ibe_rev_gap_value .

      # Get the revenue gap value
      ?ibe_rev_gap_value :has_decimal_value ?revenue_gap_value_literal .
      BIND(xsd:decimal(?revenue_gap_value_literal) AS ?revenue_gap_value)
    }
  }
}
GROUP BY ?part_number
"""

# Execute the query
with stardog.Connection(database_name, **conn_details) as conn:
    results_part_number = conn.select(query_part_number)

Cell 7: Parse Results into DataFrame

python

# Parse the results
data_part_number = results_part_number
variables = data_part_number['head']['vars']
bindings = data_part_number['results']['bindings']
rows = []

for binding in bindings:
    row = {}
    for var in variables:
        if var in binding:
            value = binding[var]['value']
            # Convert numerical values
            if binding[var]['type'] == 'literal' and 'datatype' in binding[var]:
                datatype = binding[var]['datatype']
                if datatype in (
                    'http://www.w3.org/2001/XMLSchema#decimal',
                    'http://www.w3.org/2001/XMLSchema#float',
                    'http://www.w3.org/2001/XMLSchema#double',
                    'http://www.w3.org/2001/XMLSchema#integer',
                    'http://www.w3.org/2001/XMLSchema#int',
                ):
                    value = float(value)
            row[var] = value
        else:
            row[var] = None
    rows.append(row)

# Create DataFrame
df_part_number = pd.DataFrame(rows)
df_part_number['total_revenue_gap'] = pd.to_numeric(df_part_number['total_revenue_gap'])

Cell 8: Plot Part Number-wise Data

python

# Sort data
df_part_number = df_part_number.sort_values('total_revenue_gap', ascending=False)

# Set figure size
plt.figure(figsize=(12, len(df_part_number) * 0.5))

# Create horizontal bar chart
bars = plt.barh(df_part_number['part_number'], df_part_number['total_revenue_gap'], color='skyblue')

# Format x-axis with currency
plt.gca().xaxis.set_major_formatter(formatter)

# Add labels and title
plt.xlabel('Total Revenue Gap', fontsize=14)
plt.ylabel('Part Number', fontsize=14)
plt.title('Total Revenue Gap per Part Number', fontsize=16)

# Adjust y-ticks
plt.yticks(fontsize=10)

# Invert y-axis
plt.gca().invert_yaxis()

# Adjust layout
plt.tight_layout()

# Show plot
plt.show()

5. Plot Engine-wise Data

Finally, let's do the same for engine models.
Cell 9: Define and Execute Engine-wise Query

python

# Define the SPARQL query for engine-wise data
query_engine = """
PREFIX : <http://api.stardog.com/>
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>

SELECT ?engine_model_name (ROUND(SUM(?revenue_gap_value) * 1000) / 1000 AS ?total_revenue_gap)
WHERE {
  {
    SELECT DISTINCT ?engine_model_name ?revenue_gap ?revenue_gap_value
    WHERE {
      # Ensure we're dealing with engine models
      ?artifact_identifier_engine_model rdf:type :Designative_Information_Content_Entity .
      ?artifact_identifier_engine_model :designates ?engine_model .
      ?engine_model rdf:type :Artifact_Model .
      ?artifact_identifier_engine_model :generically_depends_on ?ibe_engine_model .
      ?ibe_engine_model :has_text_value ?engine_model_name .
      FILTER(STRSTARTS(STR(?engine_model), STR(:engine_model_)))

      # Exclude "N/A" values
      FILTER(?engine_model_name != "N/A" && ?engine_model_name != "")

      # Engine model prescribes part aggregates
      ?engine_model :prescribes ?part_aggregate .

      # Part aggregate bears revenue gaps
      ?part_aggregate :bearer_of ?revenue_gap .

      # Retrieve the measurement of the revenue gap
      ?measurement :is_measurement_of ?revenue_gap .
      ?measurement :generically_depends_on ?ibe_rev_gap_value .

      # Get the revenue gap value
      ?ibe_rev_gap_value :has_decimal_value ?revenue_gap_value_literal .
      BIND(xsd:decimal(?revenue_gap_value_literal) AS ?revenue_gap_value)
    }
  }
}
GROUP BY ?engine_model_name
"""

# Execute the query
with stardog.Connection(database_name, **conn_details) as conn:
    results_engine = conn.select(query_engine)

Cell 10: Parse Results into DataFrame

python

# Parse the results
data_engine = results_engine
variables = data_engine['head']['vars']
bindings = data_engine['results']['bindings']
rows = []

for binding in bindings:
    row = {}
    for var in variables:
        if var in binding:
            value = binding[var]['value']
            # Convert numerical values
            if binding[var]['type'] == 'literal' and 'datatype' in binding[var]:
                datatype = binding[var]['datatype']
                if datatype in (
                    'http://www.w3.org/2001/XMLSchema#decimal',
                    'http://www.w3.org/2001/XMLSchema#float',
                    'http://www.w3.org/2001/XMLSchema#double',
                    'http://www.w3.org/2001/XMLSchema#integer',
                    'http://www.w3.org/2001/XMLSchema#int',
                ):
                    value = float(value)
            row[var] = value
        else:
            row[var] = None
    rows.append(row)

# Create DataFrame
df_engine = pd.DataFrame(rows)
df_engine['total_revenue_gap'] = pd.to_numeric(df_engine['total_revenue_gap'])

Cell 11: Plot Engine-wise Data

python

# Sort data
df_engine = df_engine.sort_values('total_revenue_gap', ascending=False)

# Set figure size
plt.figure(figsize=(12, len(df_engine) * 0.5))

# Create horizontal bar chart
bars = plt.barh(df_engine['engine_model_name'], df_engine['total_revenue_gap'], color='skyblue')

# Format x-axis with currency
plt.gca().xaxis.set_major_formatter(formatter)

# Add labels and title
plt.xlabel('Total Revenue Gap', fontsize=14)
plt.ylabel('Engine Model Name', fontsize=14)
plt.title('Total Revenue Gap per Engine Model', fontsize=16)

# Adjust y-ticks
plt.yticks(fontsize=10)

# Invert y-axis
plt.gca().invert_yaxis()

# Adjust layout
plt.tight_layout()

# Show plot
plt.show()

=============================================================================================

6. Additional Tips for Large Datasets

When dealing with large datasets, consider the following:

    Interactive Plots: Use interactive plotting libraries like plotly or bokeh to enable zooming and panning.

    python

import plotly.express as px

fig = px.bar(df_top, x='total_revenue_gap', y='customer_name', orientation='h',
             labels={'total_revenue_gap': 'Total Revenue Gap', 'customer_name': 'Customer Name'},
             title='Total Revenue Gap per Customer')
fig.update_layout(yaxis={'categoryorder':'total ascending'})
fig.show()

Limiting Data: If the number of entries is too large, consider plotting only the top N entries or those above a certain threshold.

python

# Filter data to entries with revenue gap above a certain value
df_filtered = df[df['total_revenue_gap'] > 10000]  # Adjust threshold as needed

Adjusting Figure Size: If labels still overlap, further increase the figure height or reduce font size.

Rotating Labels: If names are long, you can wrap or rotate them.

python

    plt.yticks(fontsize=10, rotation=0)

7. Conclusion

By following these steps, you can:

    Plot all your data with improved visuals.
    Execute and plot different SPARQL queries within your Python notebook.
    Customize plots to suit your preferences and data size.

Feel free to adjust the code further to meet your specific needs, and let me know if you have any questions or need additional assistance!

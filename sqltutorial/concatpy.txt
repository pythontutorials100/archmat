import csv

def read_base_triplets(filename):
    """Reads the base triplets from a CSV file, excluding certain example literal values."""
    base_triplets = []
    skip_predicates = {'has text value', 'has decimal value', 'has integer value'}
    with open(filename, 'r', encoding='utf-8') as csvfile:
        reader = csv.reader(csvfile)
        base_header = next(reader)  # Skip header
        for row in reader:
            if len(row) >= 3:
                subject, predicate, obj = row[0].strip(), row[1].strip(), row[2].strip()
                if predicate not in skip_predicates:
                    base_triplets.append((subject, predicate, obj))
    return base_triplets

def read_individuals_data(filename):
    """Reads the individuals data from a CSV file."""
    individuals_data = []
    with open(filename, 'r', encoding='utf-8-sig', newline='') as csvfile:
        reader = csv.DictReader(csvfile)
        first_row = True
        for row in reader:
            if first_row:
                print("Column headers:", list(row.keys()))
                first_row = False
            individuals_data.append(row)
    return individuals_data

def generate_new_triplets(individuals_data, starting_index=2):
    """Generates new triplets based on individuals data."""
    new_triplets = []
    entity_counter = starting_index  # Starting index for new entities
    for row in individuals_data:
        # Extract values from the row
        operator = row.get('OPERATOR', '').strip()
        ac_platform = row.get('AC_PLATFORM', '').strip()
        engine_master_series = row.get('ENGINE_MASTER_SERIES', '').strip()
        part_number = row.get('P/N', '').strip()
        bu = row.get('BU', '').strip()
        year = row.get('YEAR', '').strip()
        revenue_gap = row.get('REVENUE_GAP', '').strip()
        # Additional fields as needed

        # Debugging statements
        print(f"Processing entity {entity_counter}")
        print(f"Operator: {operator}")
        print(f"AC_PLATFORM: {ac_platform}")
        print(f"ENGINE_MASTER_SERIES: {engine_master_series}")
        print(f"P/N: {part_number}")
        print(f"BU: {bu}")
        print(f"YEAR: {year}")
        print(f"REVENUE_GAP: {revenue_gap}")

        # Continue only if mandatory fields are present
        if not operator:
            print(f"Warning: Missing operator for entity {entity_counter}. Skipping.")
            continue
        if not ac_platform:
            print(f"Warning: Missing AC_PLATFORM for entity {entity_counter}.")
        if not part_number:
            print(f"Warning: Missing P/N (part number) for entity {entity_counter}.")

        # Generate unique identifiers
        customer_id = f"customer_{entity_counter}"
        ibe_cust_id = f"ibe_cust_{entity_counter}"
        designative_name_customer_id = f"designative_name_customer_{entity_counter}"

        part_aggregate_id = f"part_aggregate_{entity_counter}"
        revenue_gap_id = f"revenue_gap_{entity_counter}"
        measurement_ice_rev_gap_id = f"measurement_ice_rev_gap_{entity_counter}"
        ibe_rev_gap_value_id = f"ibe_rev_gap_value_{entity_counter}"

        revenue_gap_base_year_id = f"revenue_gap_base_year_{entity_counter}"
        ibe_year_id = f"ibe_year_{entity_counter}"
        temporal_interval_identifier_rgb_id = f"temporal_interval_identifier_rgb_{entity_counter}"
        stasis_of_revenue_gap_id = f"stasis_of_revenue_gap_{entity_counter}"
        business_process_id = f"business_process_{entity_counter}"

        sub_business_unit_id = f"sub_business_unit_{entity_counter}"
        ibe_sbu_id = f"ibe_sbu_{entity_counter}"
        designative_name_sbu_id = f"designative_name_sbu_{entity_counter}"

        aircraft_model_id = f"aircraft_model_{entity_counter}"
        ibe_aircraft_model_id = f"ibe_aircraft_model_{entity_counter}"
        artifact_identifier_aircraft_model_id = f"artifact_identifier_aircraft_model_{entity_counter}"

        engine_model_id = f"engine_model_{entity_counter}"
        ibe_engine_model_id = f"ibe_engine_model_{entity_counter}"
        artifact_identifier_engine_model_id = f"artifact_identifier_engine_model_{entity_counter}"

        part_model_id = f"part_model_{entity_counter}"
        ibe_part_model_id = f"ibe_part_model_{entity_counter}"
        artifact_identifier_part_model_id = f"artifact_identifier_part_model_{entity_counter}"

        # Generate triplets
        # Customer uses Part Aggregate
        new_triplets.append((customer_id, 'uses', part_aggregate_id))
        new_triplets.append((designative_name_customer_id, 'generically depends on', ibe_cust_id))
        new_triplets.append((designative_name_customer_id, 'designates', customer_id))

        # Part Aggregate bearer of Revenue Gap
        new_triplets.append((part_aggregate_id, 'bearer of', revenue_gap_id))
        new_triplets.append((part_aggregate_id, 'participates in', business_process_id))
        new_triplets.append((revenue_gap_id, 'participates in', stasis_of_revenue_gap_id))
        new_triplets.append((revenue_gap_id, 'is about', customer_id))

        # Measurement of Revenue Gap
        new_triplets.append((measurement_ice_rev_gap_id, 'is measurement of', revenue_gap_id))
        new_triplets.append((measurement_ice_rev_gap_id, 'generically depends on', ibe_rev_gap_value_id))
        new_triplets.append((ibe_rev_gap_value_id, 'uses measurement unit', 'United States Dollar'))

        # Temporal Information
        new_triplets.append((temporal_interval_identifier_rgb_id, 'designates', revenue_gap_base_year_id))
        new_triplets.append((temporal_interval_identifier_rgb_id, 'generically depends on', ibe_year_id))
        new_triplets.append((stasis_of_revenue_gap_id, 'occurs on', revenue_gap_base_year_id))

        # Sub Business Unit
        new_triplets.append((sub_business_unit_id, 'participates in', business_process_id))
        new_triplets.append((designative_name_sbu_id, 'designates', sub_business_unit_id))
        new_triplets.append((designative_name_sbu_id, 'generically depends on', ibe_sbu_id))

        # Customer participates in Business Process
        new_triplets.append((customer_id, 'participates in', business_process_id))

        # Artifact Models prescribe Part Aggregate
        new_triplets.append((aircraft_model_id, 'prescribes', part_aggregate_id))
        new_triplets.append((engine_model_id, 'prescribes', part_aggregate_id))
        new_triplets.append((part_model_id, 'prescribes', part_aggregate_id))

        # Artifact Identifiers and IBEs
        new_triplets.append((artifact_identifier_aircraft_model_id, 'generically depends on', ibe_aircraft_model_id))
        new_triplets.append((artifact_identifier_aircraft_model_id, 'designates', aircraft_model_id))
        new_triplets.append((artifact_identifier_engine_model_id, 'generically depends on', ibe_engine_model_id))
        new_triplets.append((artifact_identifier_engine_model_id, 'designates', engine_model_id))
        new_triplets.append((artifact_identifier_part_model_id, 'generically depends on', ibe_part_model_id))
        new_triplets.append((artifact_identifier_part_model_id, 'designates', part_model_id))

        # Literal Values
        new_triplets.append((ibe_cust_id, 'has text value', operator))
        new_triplets.append((ibe_rev_gap_value_id, 'has decimal value', revenue_gap))
        new_triplets.append((ibe_year_id, 'has integer value', year))
        new_triplets.append((ibe_aircraft_model_id, 'has text value', ac_platform))
        new_triplets.append((ibe_sbu_id, 'has text value', bu))
        new_triplets.append((ibe_engine_model_id, 'has text value', engine_master_series))
        new_triplets.append((ibe_part_model_id, 'has text value', part_number))

        # RDF Types
        new_triplets.append((ibe_cust_id, 'rdf:type', 'Information Bearing Entity'))
        new_triplets.append((designative_name_customer_id, 'rdf:type', 'Designative Information Content Entity'))
        new_triplets.append((customer_id, 'rdf:type', 'Customer Organization'))
        new_triplets.append((ibe_rev_gap_value_id, 'rdf:type', 'Information Bearing Entity'))
        new_triplets.append((revenue_gap_id, 'rdf:type', 'Quality'))
        new_triplets.append((measurement_ice_rev_gap_id, 'rdf:type', 'Ratio Measurement Information Content Entity'))
        new_triplets.append(('United States Dollar', 'rdf:type', 'Measurement Unit of Currency'))
        new_triplets.append((revenue_gap_base_year_id, 'rdf:type', 'Year'))
        new_triplets.append((temporal_interval_identifier_rgb_id, 'rdf:type', 'Temporal Interval Identifier'))
        new_triplets.append((ibe_year_id, 'rdf:type', 'Information Bearing Entity'))
        new_triplets.append((stasis_of_revenue_gap_id, 'rdf:type', 'Stasis of Quality'))
        new_triplets.append((sub_business_unit_id, 'rdf:type', 'Commercial Organization'))
        new_triplets.append((designative_name_sbu_id, 'rdf:type', 'Designative Information Content Entity'))
        new_triplets.append((ibe_sbu_id, 'rdf:type', 'Information Bearing Entity'))
        new_triplets.append((business_process_id, 'rdf:type', 'Planned Act'))
        new_triplets.append((aircraft_model_id, 'rdf:type', 'Artifact Model'))
        new_triplets.append((ibe_aircraft_model_id, 'rdf:type', 'Information Bearing Entity'))
        new_triplets.append((artifact_identifier_aircraft_model_id, 'rdf:type', 'Designative Information Content Entity'))
        new_triplets.append((engine_model_id, 'rdf:type', 'Artifact Model'))
        new_triplets.append((ibe_engine_model_id, 'rdf:type', 'Information Bearing Entity'))
        new_triplets.append((artifact_identifier_engine_model_id, 'rdf:type', 'Designative Information Content Entity'))
        new_triplets.append((part_model_id, 'rdf:type', 'Artifact Model'))
        new_triplets.append((ibe_part_model_id, 'rdf:type', 'Information Bearing Entity'))
        new_triplets.append((artifact_identifier_part_model_id, 'rdf:type', 'Designative Information Content Entity'))
        new_triplets.append((part_aggregate_id, 'rdf:type', 'Object Aggregate'))

        # Increment the counter
        entity_counter += 1

    return new_triplets

def write_triplets_to_csv(triplets, filename):
    """Writes triplets to a CSV file."""
    with open(filename, 'w', encoding='utf-8', newline='') as csvfile:
        writer = csv.writer(csvfile)
        writer.writerow(['Subject', 'Predicate', 'Object'])
        for triplet in triplets:
            writer.writerow(triplet)

def main():
    # Read base triplets
    base_triplets = read_base_triplets('output_triplets_pnc4_cu.csv')

    # Read individuals data
    individuals_data = read_individuals_data('Data_Anzo1.csv')

    # Generate new triplets
    # Assuming the base entities end with index 1, so new entities start from 2
    new_triplets = generate_new_triplets(individuals_data, starting_index=2)

    # Combine base triplets with new triplets
    combined_triplets = base_triplets + new_triplets

    # Write combined triplets to a new CSV file
    write_triplets_to_csv(combined_triplets, 'combined_triplets_pnc4.csv')

if __name__ == '__main__':
    main()



================

entire graph:

PREFIX : <http://api.stardog.com/>
PREFIX cco: <http://www.ontologyrepository.com/CommonCoreOntologies/>
PREFIX edsq1: <tag:stardog:studio:edsq1:model:>
PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>
PREFIX owl: <http://www.w3.org/2002/07/owl#>

CONSTRUCT {
  ?subject ?predicate ?object .
}
WHERE {
  ?subject ?predicate ?object .
  FILTER (?subject != owl:Class && ?object != owl:Class)
}


============

customer wise:

PREFIX : <http://api.stardog.com/>
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>

SELECT ?customer_name (ROUND(SUM(?revenue_gap_value) * 1000) / 1000 AS ?total_revenue_gap)
WHERE {
  # Retrieve the IBE that contains the customer name
  ?ibe_cust :has_text_value ?customer_name .
  ?designative_name_customer :generically_depends_on ?ibe_cust .
  ?designative_name_customer :designates ?customer .
  ?customer rdf:type :Customer_Organization .

  # Retrieve the revenue gap associated with the customer
  ?revenue_gap :is_about ?customer .

  # Retrieve the measurement of the revenue gap
  ?measurement :is_measurement_of ?revenue_gap .
  ?measurement :generically_depends_on ?ibe_rev_gap_value .

  # Get the revenue gap value
  ?ibe_rev_gap_value :has_decimal_value ?revenue_gap_value_literal .
  BIND(xsd:decimal(?revenue_gap_value_literal) AS ?revenue_gap_value)
}
GROUP BY ?customer_name


================

aircraft wise:

PREFIX : <http://api.stardog.com/>
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>

SELECT ?aircraft_model_name (ROUND(SUM(?revenue_gap_value) * 1000) / 1000 AS ?total_revenue_gap)
WHERE {
  {
    SELECT DISTINCT ?aircraft_model_name ?revenue_gap ?revenue_gap_value
    WHERE {
      # Ensure we're dealing with aircraft models
      ?artifact_identifier_aircraft_model rdf:type :Designative_Information_Content_Entity .
      ?artifact_identifier_aircraft_model :designates ?aircraft_model .
      ?aircraft_model rdf:type :Artifact_Model .
      ?artifact_identifier_aircraft_model :generically_depends_on ?ibe_aircraft_model .
      ?ibe_aircraft_model :has_text_value ?aircraft_model_name .
      FILTER(STRSTARTS(STR(?aircraft_model), STR(:aircraft_model_)))

      # Aircraft model prescribes part aggregates
      ?aircraft_model :prescribes ?part_aggregate .

      # Part aggregate bears revenue gaps
      ?part_aggregate :bearer_of ?revenue_gap .

      # Retrieve the measurement of the revenue gap
      ?measurement :is_measurement_of ?revenue_gap .
      ?measurement :generically_depends_on ?ibe_rev_gap_value .

      # Get the revenue gap value
      ?ibe_rev_gap_value :has_decimal_value ?revenue_gap_value_literal .
      BIND(xsd:decimal(?revenue_gap_value_literal) AS ?revenue_gap_value)
    }
  }
}
GROUP BY ?aircraft_model_name



=====================


engine wise:

PREFIX : <http://api.stardog.com/>
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>

SELECT ?engine_model_name (ROUND(SUM(?revenue_gap_value) * 1000) / 1000 AS ?total_revenue_gap)
WHERE {
  {
    SELECT DISTINCT ?engine_model_name ?revenue_gap ?revenue_gap_value
    WHERE {
      # Ensure we're dealing with engine models
      ?artifact_identifier_engine_model rdf:type :Designative_Information_Content_Entity .
      ?artifact_identifier_engine_model :designates ?engine_model .
      ?engine_model rdf:type :Artifact_Model .
      ?artifact_identifier_engine_model :generically_depends_on ?ibe_engine_model .
      ?ibe_engine_model :has_text_value ?engine_model_name .
      FILTER(STRSTARTS(STR(?engine_model), STR(:engine_model_)))

      # Exclude "N/A" values
      FILTER(?engine_model_name != "N/A" && ?engine_model_name != "")

      # Engine model prescribes part aggregates
      ?engine_model :prescribes ?part_aggregate .

      # Part aggregate bears revenue gaps
      ?part_aggregate :bearer_of ?revenue_gap .

      # Retrieve the measurement of the revenue gap
      ?measurement :is_measurement_of ?revenue_gap .
      ?measurement :generically_depends_on ?ibe_rev_gap_value .

      # Get the revenue gap value
      ?ibe_rev_gap_value :has_decimal_value ?revenue_gap_value_literal .
      BIND(xsd:decimal(?revenue_gap_value_literal) AS ?revenue_gap_value)
    }
  }
}
GROUP BY ?engine_model_name



================

partneumber wise:


PREFIX : <http://api.stardog.com/>
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>

SELECT ?part_number (ROUND(SUM(?revenue_gap_value) * 1000) / 1000 AS ?total_revenue_gap)
WHERE {
  {
    SELECT DISTINCT ?part_number ?revenue_gap ?revenue_gap_value
    WHERE {
      # Ensure we're dealing with part models
      ?artifact_identifier_part_model rdf:type :Designative_Information_Content_Entity .
      ?artifact_identifier_part_model :designates ?part_model .
      ?part_model rdf:type :Artifact_Model .
      ?artifact_identifier_part_model :generically_depends_on ?ibe_part_model .
      ?ibe_part_model :has_text_value ?part_number .
      FILTER(STRSTARTS(STR(?part_model), STR(:part_model_)))

      # Part model prescribes part aggregates
      ?part_model :prescribes ?part_aggregate .

      # Part aggregate bears revenue gaps
      ?part_aggregate :bearer_of ?revenue_gap .

      # Retrieve the measurement of the revenue gap
      ?measurement :is_measurement_of ?revenue_gap .
      ?measurement :generically_depends_on ?ibe_rev_gap_value .

      # Get the revenue gap value
      ?ibe_rev_gap_value :has_decimal_value ?revenue_gap_value_literal .
      BIND(xsd:decimal(?revenue_gap_value_literal) AS ?revenue_gap_value)
    }
  }
}
GROUP BY ?part_number



==================================
